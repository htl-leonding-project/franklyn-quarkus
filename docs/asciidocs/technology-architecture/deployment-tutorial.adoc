= AsciiDoc Article Title
Firstname Lastname <author@asciidoctor.org>
3.0, July 29, 2022: AsciiDoc article template
:toc:
:icons: font
:url-quickref: https://docs.asciidoctor.org/asciidoc/latest/syntax-quick-reference/


== Description

In diesem Tutorial geht werden wir eine Postgresql Datenbank, Quarkus Backend und ein Angular Client deployen


== Requirments


- kubectl muss intsalliert und konfiguriert sein
- Kind oder Minikube
- Linux oder WSL2 Terminal
- Docker muss installiert sein

== Allgemeine Regeln

=== Wichtige Begriffe

==== Pod
---

Ein Pod besteht aus einem oder mehreren (Docker, Podman, usw.) Containern


==== Deployment
---

Mit einem Deployment kann man ein Pod erstellen und dabei festlegen, welche und wie viele Secrets, Volumes, CPUs, RAM und Replikationen für diesen benötigt werden.

==== Node

'''
Eine physikalische oder eine virtuelle Maschine, wo mehrere Pods darauf rennen

==== Service

'''
Um einen Zugriff auf die Pods mittels REST, TCP oder andere Protokolle zu erhalten, werden sogenannte Services verwendet

==== ConfigMaps

'''
Damit ein Pod einen Zugriff auf Umgebungsvariablen erhält, wird dafür eine ConfigMap verwendet

==== Secrets

'''
Ähnlich wie bei einer ConfigMap. Allerdings werden Secrets für sensible Daten wie zum Beispiel Credentials (Login Daten)
verwendet.

==== Persistence Volume

'''
Damit die Daten im Falle eines Ausfalls eines Servers nicht verloren gehen, werden sogenannte Volumes erstellt.
Diese sind vergleichbar mit docker volumes.

==== Persistence Volume Claim (PVC)

'''
Damit ein Pod auf einer Persistence Volume zugreifen kann, werden Persistence Volume Claim (PVC) verwendet.

NOTE: Schüler haben keinen Zugriff auf die Persistence Volumes von der Leocloud.

---

Grundsätzlich braucht für jede Komponente in unserem System ein Deployment


== Deployment von einer Postresql Datenbank


----
kubectl create deployment postgres-demo --image=postgres:12.16-bullseye --port=5432
----
Folgender  Befehl wurde verwendet, um ein Deployment für unsere Datenbank zu erstellen.


=== Warum rennt die Datenbank nicht

Wenn man jetzt `kubectl get pods` oder `kubectl get deployments` im Terminal eingibt, dann könnte man sehen, dass bei der Spalten `Ready` #0/1#  dabei steht.
Um das Problem zu finden können wir folgendes machen.
Wir kopieren uns den Namen des Pods in der Zwischen ablage und geben dann folgendes im Terminal ein
----
kubectl log <Name des Pods> -c <Name des Images, welches von dem Pod verwendet wird>
----

In meinem Fall habe ich folgendes eingeben müssen

----
kubectl logs postgres-demo-7cd674d4b5-9msfr -c postgres
----

Die Fehlermeldung schaut wie folgends aus:

----

Error: Database is uninitialized and superuser password is not specified.
       You must specify POSTGRES_PASSWORD to a non-empty value for the
       superuser. For example, "-e POSTGRES_PASSWORD=password" on "docker run".

       You may also use "POSTGRES_HOST_AUTH_METHOD=trust" to allow all
       connections without a password. This is *not* recommended.

       See PostgreSQL documentation about "trust":
       https://www.postgresql.org/docs/current/auth-trust.html

----

Für das Lösen dieses Problems müssen wir jetzt ein ConfigMap oder ein Secret erstellen, wo wir die benötigten Umgebungsvariablen definieren können.


NOTE: `kubectl get deployments/postgres-demo -o yaml > deployment.yaml` im Terminal eingeben, damit man die ganze Konfiguration von dem Deployment in einem YAML File speichert. (Das könnte man auch bei Services, Secrets usw. auch machen ). Es lohnt sich auch, diesen Befehl nach jeder Änderung zu machen und die Files STÄNDIG zu kontrollieren.

=== Erstellung von des Secrets

Für die Erstellung des Secrets kann man diesen Befehl verwenden

----
kubectl create secret generic  postgres-secret \
--from-literal=POSTGRES_USER=<Name des Users> \
--from-literal=POSTGRES_PASSWORD=<Password> \
--from-literal=POSTGRES_DB=<Name der DBs>
----

NOTE: Die Argumente,welches nach `--from-literal` kommt, soll mit den Namen der benötigten Umgebenungsvariablen übereinstimmen. Das zweite Argument ist einfach der Wert dieser Umgebungsvariable.

Jetzt kann man die Konfigurationen von unserem Secret mit der Verwendung von diesem Befehl in einem YAML File speichern

----
kubectl get secrets postgres-secret -o yaml > secret.yaml
----

Wir sind aber noch immer nicht fertig mit dem Secret. Das Deployment soll sich die Werte von diesem Secret für seine Umgebungsvariablen lösen. Dafür muss man folgendes im Terminal eingeben:

----
kubectl set env deployment/postgres-demo --from=secret/postgres-secret
----

Unser Deployment soll jetzt problemlos funktionieren.
Wenn das nicht der Fall ist könnte man folgendes machen (Nicht vergessen, YAML Files mit Hilfe der kubectl CLI zu generieren):

----
kubectl delete deployments/postgres-demo
kubectl apply -f postgres.yaml
----

=== Erstellung einer Service

Wir haben die Datenbank jetzt zum Laufen gebracht. Damit wir auf diese zugreifen können müssen wir eine Service erstellen:

----
kubectl expose deployments/postgres-demo --type=LoadBalancer --port=5432
kubectl get services
----

Connection String von postgres schaut dann wie folgendes aus:
----
jdbc:postgresql://<Minikube IP>:<NodePort>/db
----
die Minikube IP kann man mit dem Befehl `minikube ip` anzeigen lassen. beim NodePort muss mann `kubectl get services/postgres-demo` eingeben und dann den Port, welcher nach dem Doppelpunkt steht nehmen

== Persistence Volume/Persistence Volume Claim

Bei der Leocloud sind diese schon definiert. Auf dem lokalen Minikube könnte man diese Konfiguration verwenden

[source,yaml]
----
apiVersion: v1
kind: PersistentVolume
metadata:
  finalizers:
  - kubernetes.io/pv-protection
  labels:
    type: local
  name: task-pv-volume
  resourceVersion: "33077"
  uid: ae6d772a-0090-4074-b3ac-1edb929daf29
spec:
  accessModes:
  - ReadWriteOnce
  capacity:
    storage: 10Gi
  hostPath:
    path: /mnt/data
    type: ""
  persistentVolumeReclaimPolicy: Retain
  storageClassName: manual
  volumeMode: Filesystem
status:
  phase: Available


----

[source,yaml]
----
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  finalizers:
  - kubernetes.io/pvc-protection
  name: franklyn-pvc
  namespace: default
spec:
    accessModes:
      - ReadWriteMany
    resources:
      requests:
        storage: 10Mi
    storageClassName: standard

----


Wir brauchen noch ein PVC, damit die Datenbank später ein SQL lesen und ausführen kann

Folgende Konfiguration kann dafür verwendet werden




Jetzt muss unser Deployment umkonfigurieren, sodass es dieses Volume verwendet.
Leider können wir diese Konfigurationen nicht mit der Verwendung von der kubectl CLI hinzufügen. Deshalb habe ich sie in diesem Code-Snippet markiert.
(Ich rate Ihnen, den Code nicht zu kopieren, sondern nur die Zeilen, die einen Plus enthalten, in ihrem Config Files händisch hinzufügen. Ohne die Plus-Symbole natürlich)




[source,diff]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  annotations:
    deployment.kubernetes.io/revision: "2"
  generation: 2
  labels:
    app: postgres-demo
  name: postgres-demo
  namespace: default
  resourceVersion: "40443"
  uid: 5e97ba55-98ff-454d-9247-946157c8a5ec
spec:
  progressDeadlineSeconds: 600
  replicas: 1
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      app: postgres-demo
  strategy:
    rollingUpdate:
      maxSurge: 25%
      maxUnavailable: 25%
    type: RollingUpdate
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: postgres-demo
    spec:
      containers:
      - env:
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              key: POSTGRES_PASSWORD
              name: postgres-secret
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              key: POSTGRES_USER
              name: postgres-secret
        - name: POSTGRES_DB
          valueFrom:
            secretKeyRef:
              key: POSTGRES_DB
              name: postgres-secret
        image: postgres:12.16-bullseye
        imagePullPolicy: IfNotPresent
        name: postgres
+        volumeMounts:
+          - name: postgres-data
+            mountPath: /var/lib/postgresql/data
        ports:
        - containerPort: 5432
          protocol: TCP
        resources: {}
        terminationMessagePath: /dev/termination-log
        terminationMessagePolicy: File
      dnsPolicy: ClusterFirst
      restartPolicy: Always
      schedulerName: default-scheduler
      securityContext: {}
      terminationGracePeriodSeconds: 30

+      volumes:
+        - name: postgres-data
+          persistentVolumeClaim:
+            claimName: my-pvc

----
Es ist jetzt völlig egal, ob die Pods aus irgendeinem Grund gestoppt oder gekillt werden. Die Daten existieren noch immer.

Gratuliere! Sie haben jetzt die Datenbank erfolgreich deployed :)

Wenn Sie das Program auf ihren Namespace deployen wollen, dann müssen Sie bei jedem YAML File das Attribut `namespace` ändern


== Deployment einer Java Applikation

<Comming soon>

== Deployment einer Angular Applikation

<Coming soon>
